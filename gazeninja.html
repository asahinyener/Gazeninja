<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gaze-OS Living Room</title>
  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
  <style>
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: system-ui, sans-serif;
    }
    #calibrationArea {
      position: relative;
      width: 1024px;
      height: 768px;
      margin: auto;
      border: 2px solid #444;
      overflow: hidden;
      background: #000;
    }
    #roomCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 10;
    }
    #gazeDot, #gazeDotEMA {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      position: absolute;
      pointer-events: none;
      display: none;
    }
    #gazeDot { background: rgba(255,0,0,.6); z-index: 30; }
    #gazeDotEMA { background: rgba(0,140,255,.7); z-index: 29; }
    .calibration-point {
      width: 18px; height: 18px;
      background: #f44336;
      border-radius: 50%;
      position: absolute;
      cursor: pointer;
      z-index: 50;
      transition: transform .15s ease-out;
    }
    button {
      position: absolute;
      bottom: 10px;
      left: 10px;
      padding: 6px 12px;
      font-size: .9rem;
      z-index: 60;
    }
  </style>
</head>
<body>
  <div id="calibrationArea">
    <canvas id="roomCanvas"></canvas>
    <div id="gazeDot"></div>
    <div id="gazeDotEMA"></div>
  </div>
  <button id="calBtn">Start Calibration</button>

  <script>
  // ---- DOM & Canvas Setup ----
  const area    = document.getElementById('calibrationArea');
  const canvas  = document.getElementById('roomCanvas');
  const ctx     = canvas.getContext('2d');
  const gazeDot    = document.getElementById('gazeDot');
  const gazeDotEMA = document.getElementById('gazeDotEMA');
  const calBtn     = document.getElementById('calBtn');

  let areaRect, darkMode = true, lastId = null;
  let emaX = null, emaY = null;
  const ALPHA = 0.15;

  // ---- Dwell & Scaling State ----
  let dwellStart = 0;
  const DWELL_THRESHOLD = 1200;       // ms to trigger selection
  const MAX_SCALE = 2.5;              // maximum grow factor
  const SCALE_RATE = (MAX_SCALE - 1) / DWELL_THRESHOLD;

  // ---- URL Mapping for launches ----
  const urlMap = {
    tv:         'https://www.netflix.com',
    bookshelf:  'https://en.wikipedia.org',
    sofa_game:  'https://store.steampowered.com',
    sofa_web:   'https://www.google.com',
    phone:      'https://www.chatgpt.com',
    files:      'https://drive.google.com'
    // add more if needed…,
  };

  // ---- Furniture Hit-Regions (1024×768 coords) ----
  const furniture = [
    { id: 'bookshelf',  x:  44,  y: 36, w: 249, h: 526 },
    { id: 'sofa_web',   x: 350,  y:309, w: 127, h: 124 },
    { id: 'sofa_game',  x: 543,  y:301, w: 123, h: 124 },
    { id: 'phone',      x: 704,  y:284, w: 131, h: 125 },
    { id: 'lamp',       x: 812,  y: 87, w: 107, h: 134 },
    { id: 'tv',         x: 842,  y:275, w: 171, h: 198 },
    { id: 'files',      x: 500,  y:465, w: 101, h:  89 },
  ];

  // ---- Load Background & Initial draw ----
  const bg = new Image();
  bg.src = 'livingroom.png';
  bg.onload = () => {
    resizeCanvas();
    areaRect = area.getBoundingClientRect();
    draw();
  };

  function resizeCanvas(){
    canvas.width  = area.offsetWidth;
    canvas.height = area.offsetHeight;
    areaRect = area.getBoundingClientRect();
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  // ---- DRAW: full‐room dark + bright lamp ----
  function draw(){
    const cw = canvas.width,
          ch = canvas.height;

    // draw room
    ctx.clearRect(0, 0, cw, ch);
    ctx.drawImage(bg, 0, 0, cw, ch);

    if (darkMode) {
    // 2) Build a Path2D: full-canvas rect + lamp rect
    const path = new Path2D();
    path.rect(0, 0, cw, ch);

    // map lamp coords from 1024×768 → canvas size
      const lamp = furniture.find(f => f.id === 'lamp');
    const sx = lamp.x * cw / 1024,
          sy = lamp.y * ch / 768,
          sw = lamp.w * cw / 1024,
          sh = lamp.h * ch / 768;
    path.rect(sx, sy, sw, sh);

    // 3) Fill with even-odd rule: paints blackout but leaves lamp area untouched
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fill(path, 'evenodd');  // uses the even-odd rule to create the hole :contentReference[oaicite:1]{index=1}
    }
  }
  // ---- Highlight, Scale & Launch Logic ----
  function highlightAt(normX, normY){
  let hit = furniture.find(f =>
    normX >= f.x && normX <= f.x + f.w &&
    normY >= f.y && normY <= f.y + f.h
  );
    const now = performance.now();
  if (!hit && lastId) {
    const f = furniture.find(f => f.id === lastId);
    if (f) {
      const dt    = now - dwellStart;
      const scale = Math.min(MAX_SCALE, 1 + dt * SCALE_RATE);
      const cx    = f.x + f.w/2;
      const cy    = f.y + f.h/2;
      const sw    = f.w * scale;
      const sh    = f.h * scale;
      const x0    = cx - sw/2;
      const y0    = cy - sh/2;
      const x1    = cx + sw/2;
      const y1    = cy + sh/2;
      if (normX >= x0 && normX <= x1 &&
          normY >= y0 && normY <= y1) {
        hit = f;
      }
    }
  }
    if(!hit){
      dwellStart = 0;
      if(lastId){
        lastId = null;
        draw();
      }
      return;
    }

    if(darkMode && hit.id !== 'lamp'){
      dwellStart = 0;
      if(lastId){
        lastId = null;
        draw();
      }
      return;
    }

    if(hit.id !== lastId){
      dwellStart = now;
      lastId = hit.id;
      draw();
    }

    // compute scale
    const dt = now - dwellStart;
    const scale = Math.min(MAX_SCALE, 1 + dt * SCALE_RATE);

    // glow overlay
    const cx = hit.x + hit.w/2;
    const cy = hit.y + hit.h/2;
    const sw = hit.w * scale;
    const sh = hit.h * scale;
    const sx = (cx - sw/2) * canvas.width / 1024;
    const sy = (cy - sh/2) * canvas.height / 768;
    const swp = sw * canvas.width / 1024;
    const shp = sh * canvas.height / 768;

    draw();
    ctx.save();
    ctx.beginPath();
    ctx.rect(sx, sy, swp, shp);
    ctx.fillStyle = 'rgba(255,255,200,0.5)';
    ctx.fill();
    ctx.restore();

    // label at the ORIGINAL center
    const labelX = (hit.x + hit.w/2) * canvas.width  / 1024;
    const labelY = hit.y * canvas.height / 768 - 10;
    showLabel(hit.id, labelX, labelY);

    // dwell actions
    if (dt >= DWELL_THRESHOLD) {
      dwellStart = now + 5000;
      if (hit.id === 'lamp') {
        toggleDarkMode();
      } else {
        const url = urlMap[hit.id];
        if (url) window.open(url, '_blank');
      }
    }
  }

  function showLabel(id, x, y){
    const label = id.replace('_',' ').toUpperCase();
    ctx.save();
    ctx.font = '18px sans-serif';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.strokeText(label, x - 40, y);
    ctx.fillText(label, x - 40, y);
    ctx.restore();
  }

  function toggleDarkMode(){
    darkMode = !darkMode;
    draw();
  }

  // ---- Calibration (unchanged) ----
  const GRID = [[5,5],[50,5],[95,5],[5,50],[50,50],[95,50],[5,95],[50,95],[95,95]];
  const CLICKS_PER_POINT = 3;
  let calibIndex=0, clickCount=0, calibrated=false;

  function showCalibrationPoint(){
    const [px,py] = GRID[calibIndex];
    const dot = document.createElement('div');
    dot.className = 'calibration-point';
    dot.style.left = (px/100*area.offsetWidth - 9) + 'px';
    dot.style.top  = (py/100*area.offsetHeight - 9) + 'px';
    dot.onclick = e => {
      clickCount++;
      dot.style.transform = `scale(${1 + clickCount/(CLICKS_PER_POINT*5)})`;
      webgazer.recordScreenPosition(e.clientX, e.clientY, 'click');
      if(clickCount >= CLICKS_PER_POINT){
        dot.remove();
        calibIndex++;
        clickCount = 0;
        if(calibIndex < GRID.length) showCalibrationPoint();
        else finishCalibration();
      }
    };
    area.appendChild(dot);
  }

  function startCalibration(){
    calibIndex = 0; clickCount = 0; calibrated = false;
    area.querySelectorAll('.calibration-point').forEach(n=>n.remove());
    emaX = emaY = null;
    lastId = null;
    gazeDot.style.display = gazeDotEMA.style.display = 'none';
    showCalibrationPoint();
  }

  function finishCalibration(){
    calibrated = true;
    alert('Calibration complete!');
    // now gaze tracking begins automatically
  }
// function startCalibration(){
//   calibIndex = 0; clickCount = 0; calibrated = false;
//   area.querySelectorAll('.calibration-point').forEach(n=>n.remove());
//   emaX = emaY = null;
//   lastId = null;
//   gazeDot.style.display = gazeDotEMA.style.display = 'none';
//   if(CLICKS_PER_POINT===0) finishCalibration();
//   else showCalibrationPoint();
// }

// function finishCalibration(){
//   calibrated = true;
//   alert('Calibration complete!');
//   startTracking();
// }

  calBtn.onclick = startCalibration;

  // ---- Gaze Listener ----
  webgazer
    .setGazeListener((data,ts) => {
      if(!data) return;
      const lx = data.x - areaRect.left;
      const ly = data.y - areaRect.top;
      if(lx<0||ly<0||lx>canvas.width||ly>canvas.height) return;

      if(emaX===null){
        emaX = lx; emaY = ly;
      } else {
        emaX = ALPHA*lx + (1-ALPHA)*emaX;
        emaY = ALPHA*ly + (1-ALPHA)*emaY;
      }

      gazeDot.style.left = lx + 'px';
      gazeDot.style.top  = ly + 'px';
      gazeDotEMA.style.left = emaX + 'px';
      gazeDotEMA.style.top  = emaY + 'px';
      gazeDot.style.display = gazeDotEMA.style.display = 'block';

      const normX = emaX * 1024 / canvas.width;
      const normY = emaY * 768  / canvas.height;
      highlightAt(normX, normY);
    })
    .saveDataAcrossSessions(false)
    .showVideo(true)
    .showFaceOverlay(true)
    .showFaceFeedbackBox(true)
    .applyKalmanFilter(true)
    .showPredictionPoints(false)
    .begin();
  // webgazer.setRegression("weightedRidge"); 
webgazer.setRegression("ridge"); 

  // Auto-start calibration
  startCalibration();
  </script>
</body>
</html>
