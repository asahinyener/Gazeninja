<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gaze Ninja – Trail Slice (Calibration Fixed)</title>
  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
  <style>
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:system-ui,sans-serif;background:#f5f7fa;overflow:hidden}
    h2{margin:.5rem 0;text-align:center}
    button{margin:4px;padding:6px 12px;font-size:.9rem}
    label{font-size:.9rem}

    /* ---------- Game Field ---------- */
    #calibrationArea{position:relative;width:800px;height:600px;margin:12px auto;border:2px solid #444;overflow:hidden;background:#fff}
    #trailCanvas{position:absolute;top:0;left:0;pointer-events:none;z-index:30}
    .calibration-point{width:18px;height:18px;background:#f44336;border-radius:50%;position:absolute;cursor:pointer;z-index:50;transition:transform .15s ease-out;}
    #gazeDot,#gazeDotEMA{width:14px;height:14px;border-radius:50%;position:absolute;pointer-events:none;display:none}
    #gazeDot{background:rgba(255,0,0,.6);z-index:32}
    #gazeDotEMA{background:rgba(0,140,255,.7);z-index:31}

    /* ---------- Score & debug ---------- */
    #scoreBoard,#debugPanel{position:absolute;top:10px;background:rgba(0,0,0,.55);color:#fff;padding:4px 10px;border-radius:8px;font-size:.85rem;z-index:40}
    #scoreBoard{left:10px}
    #debugPanel{right:10px;white-space:pre;font-family:monospace;text-align:left}

    /* ---------- Targets ---------- */
    .fruit{position:absolute;border-radius:50% 50% 50% 50%/60% 60% 40% 40%;box-shadow:0 4px 8px rgba(0,0,0,.25);will-change:transform,left,top;transition:transform .1s linear;pointer-events:none;}
    .fruit.sliced{animation:sliced .3s forwards}
    @keyframes sliced{to{transform:scale(0);opacity:0;}}
    .support{position:absolute;width:12px;height:12px;border-radius:50%;background:#212121;pointer-events:none;will-change:left,top,transform;opacity:.4}
  </style>
</head>
<body>
  <h2>Gaze Ninja – Trail Slice (Debug)</h2>

  <div id="calibrationArea">
    <canvas id="trailCanvas"></canvas>
    <div id="gazeDot"></div>
    <div id="gazeDotEMA"></div>
  </div>

  <!-- ---------- Controls ---------- -->
  <button id="calBtn">Start Calibration</button>
  <button id="toggleMouse">Toggle Mouse Trail</button>
  <label for="emaSlider">EMA α: <span id="emaLabel">0.20</span></label>
  <input type="range" id="emaSlider" min="0.05" max="0.50" step="0.01" value="0.20">
  <button id="startBtn" disabled>Start Tracking</button>
  <button id="stopBtn" disabled>Stop Tracking</button>

<script>
// --- Config ---
const SKIP_CALIBRATION = false;
const SHOW_SUPPORTS = true;
let USE_MOUSE_TRAIL = false;

// --- DOM ---
const area = document.getElementById('calibrationArea');
const canvas = document.getElementById('trailCanvas');
const ctx = canvas.getContext('2d');
const gazeDot = document.getElementById('gazeDot');
const gazeDotEMA = document.getElementById('gazeDotEMA');
const calBtn = document.getElementById('calBtn');
const toggleMouse = document.getElementById('toggleMouse');
const emaSlider = document.getElementById('emaSlider');
const emaLabel = document.getElementById('emaLabel');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
// **Option 1: cache layout rect**
let areaRect = area.getBoundingClientRect();
window.addEventListener('resize', () => {
  areaRect = area.getBoundingClientRect();
});
// --- Debug Panels ---
const scoreBoard = document.createElement('div'); scoreBoard.id = 'scoreBoard';
const debugPanel = document.createElement('div'); debugPanel.id = 'debugPanel';
area.appendChild(scoreBoard); area.appendChild(debugPanel);

// --- Helpers ---
const rand = (min,max) => Math.random()*(max-min)+min;
function resizeCanvas(){ canvas.width = area.offsetWidth; canvas.height = area.offsetHeight; }
resizeCanvas(); window.addEventListener('resize', resizeCanvas);

// --- Calibration ---
const GRID = [[5,5],[50,5],[95,5],[5,50],[50,50],[95,50],[5,95],[50,95],[95,95]];
const CLICKS_PER_POINT = 6;
let calibIndex = 0, clickCount = 0, calibrated = false;

// --- EMA & Trail ---
let ALPHA = parseFloat(emaSlider.value);
emaSlider.oninput = () => { ALPHA = parseFloat(emaSlider.value); emaLabel.textContent = ALPHA.toFixed(2); };
let emaX = null, emaY = null;
const TRAIL_MAX = 15, TRAIL_WIDTH = 10;
let trailPts = [];

// --- Physics ---
const GRAVITY = 200, MAX_FRUITS = 3, SUPPORT_OFFSET = 40, SUPPORT_RADIUS = 30, BASE_SPIN = 1.2;

// --- Game State ---
let fruits = [], score = 0, missed = 0, playing = false, collecting = false, lastFrame = null;

function updateScore(){ scoreBoard.textContent = `Score: ${score} | Missed: ${missed}`; }
updateScore();

function updateDebug(x,y){
  debugPanel.textContent = `fruits: ${fruits.length}\ntrail: ${trailPts.length}\nlast: ${x?.toFixed?.(1)},${y?.toFixed?.(1)}`;
}
updateDebug();

// Calibration point display
function showCalibrationPoint(){
  const [px,py] = GRID[calibIndex];
  const dot = document.createElement('div');
  dot.className = 'calibration-point';
  dot.style.left = (px/100*area.offsetWidth - 9) + 'px';
  dot.style.top  = (py/100*area.offsetHeight - 9) + 'px';
  dot.onclick = (e) => {
    clickCount++; dot.style.transform = `scale(${1 + clickCount/(CLICKS_PER_POINT*5)})`;
    webgazer.recordScreenPosition(e.clientX, e.clientY, 'click');
    if(clickCount >= CLICKS_PER_POINT){
      dot.remove(); calibIndex++; clickCount = 0;
      if(calibIndex < GRID.length) showCalibrationPoint(); else finishCalibration();
    }
  };
  area.appendChild(dot);
}

function startCalibration(){
  calibIndex = 0; clickCount = 0; calibrated = false;
  area.querySelectorAll('.calibration-point').forEach(n=>n.remove());
  fruits.forEach(f=>{ f.el.remove(); f.supportA.remove(); f.supportB.remove(); });
  fruits = []; playing = false; lastFrame = null;
  emaX = emaY = null; trailPts = [];
  score = missed = 0; updateScore();
  gazeDot.style.display = gazeDotEMA.style.display = 'none';
  startBtn.disabled = stopBtn.disabled = true;
  if(SKIP_CALIBRATION) finishCalibration(); else showCalibrationPoint();
}

function finishCalibration(){
  calibrated = true; startBtn.disabled = stopBtn.disabled = false;
  alert('Calibration complete!');
  startGame();
}

// Fruit functions
function randBetween(a,b){ return Math.random()*(b-a)+a; }
function spawnFruit(){
  const radius = randBetween(25,40);
  const x = randBetween(radius, area.offsetWidth - radius);
  const y = area.offsetHeight + radius*1.3;
  const speedY = randBetween(200,340);
  const speedX = randBetween(-120,120);
  const hue = Math.floor(randBetween(0,360));

  const el = document.createElement('div'); el.className='fruit';
  el.style.width = radius*2+'px'; el.style.height = radius*2*1.2 +'px';
  el.style.background = `radial-gradient(circle at 30% 30%, hsl(${hue} 100% 85%), hsl(${hue} 100% 50%))`;
  area.appendChild(el);
  const supportA = document.createElement('div'), supportB = document.createElement('div');
  supportA.className = supportB.className = 'support'; area.appendChild(supportA); area.appendChild(supportB);

  const fruit = { el, x, y, radius, vx: speedX, vy: -speedY, angle: 0, spin: BASE_SPIN + fruits.length*0.1, supportA, supportB };
  fruits.push(fruit);
  updateFruitPosition(fruit);
}
function updateFruitPosition(f){
  f.el.style.left = (f.x - f.radius) + 'px';
  f.el.style.top  = (f.y - f.radius*1.2) + 'px';
  f.el.style.transform = `rotate(${f.angle*180/Math.PI}deg)`;
  const sinA = Math.sin(f.angle), cosA = Math.cos(f.angle);
  const offX = SUPPORT_OFFSET * sinA;
  const offY = SUPPORT_OFFSET * cosA * 1.2;
  const ax = f.x + offX, ay = f.y - offY;
  const bx = f.x - offX, by = f.y + offY;
  f.supportA.style.left = (ax - SUPPORT_RADIUS) + 'px';
  f.supportA.style.top  = (ay - SUPPORT_RADIUS) + 'px';
  f.supportB.style.left = (bx - SUPPORT_RADIUS) + 'px';
  f.supportB.style.top  = (by - SUPPORT_RADIUS) + 'px';
}
function updateFruits(dt){
  const dts = dt/1000;
  for(let i = fruits.length-1; i>=0; i--){
    const f=fruits[i]; f.x += f.vx*dts; f.y += f.vy*dts; f.vy += GRAVITY*dts; f.angle += f.spin*dts;
    updateFruitPosition(f);
    if(f.y - f.radius*1.2 > area.offsetHeight + 100){ f.el.remove(); f.supportA.remove(); f.supportB.remove(); fruits.splice(i,1); missed++; updateScore(); }
  }
  while(fruits.length < MAX_FRUITS) spawnFruit();
}
function sliceFruit(f){
  f.el.classList.add('sliced');
  setTimeout(()=>{ f.el.remove(); f.supportA.remove(); f.supportB.remove(); },300);
  fruits.splice(fruits.indexOf(f),1); score++; updateScore();
}

// Trail functions
function addTrailPoint(x,y){ trailPts.push({x,y}); if(trailPts.length>TRAIL_MAX) trailPts.shift(); }
function drawTrail(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(trailPts.length<2) return;
  ctx.lineWidth = TRAIL_WIDTH; ctx.lineCap = 'round'; ctx.lineJoin='round'; ctx.strokeStyle = 'rgba(0,255,255,1)';
  ctx.beginPath(); ctx.moveTo(trailPts[0].x, trailPts[0].y);
  for(let i=1;i<trailPts.length;i++) ctx.lineTo(trailPts[i].x, trailPts[i].y);
  ctx.stroke();
}
function distPointToSegment(px,py,ax,ay,bx,by){
  const vx=bx-ax, vy=by-ay, wx=px-ax, wy=py-ay;
  const c1=vx*wx+vy*wy; if(c1<=0) return Math.hypot(px-ax,py-ay);
  const c2=vx*vx+vy*vy; if(c2<=c1) return Math.hypot(px-bx,py-by);
  const t=c1/c2; const ix=ax+t*vx, iy=ay+t*vy; return Math.hypot(px-ix,py-iy);
}
function checkSlices(){
  if(trailPts.length<2) return;
  for(const f of fruits){
    const sx1=parseFloat(f.supportA.style.left)+SUPPORT_RADIUS, sy1=parseFloat(f.supportA.style.top)+SUPPORT_RADIUS;
    const sx2=parseFloat(f.supportB.style.left)+SUPPORT_RADIUS, sy2=parseFloat(f.supportB.style.top)+SUPPORT_RADIUS;
    const pad = SUPPORT_RADIUS + TRAIL_WIDTH/2;
    for(let i=1;i<trailPts.length;i++){
      const ax=trailPts[i-1].x, ay=trailPts[i-1].y;
      const bx=trailPts[i].x,   by=trailPts[i].y;
      if(distPointToSegment(sx1,sy1,ax,ay,bx,by)<pad||distPointToSegment(sx2,sy2,ax,ay,bx,by)<pad){ sliceFruit(f); break; }
    }
  }
}

// Game loop
function startGame(){ playing=true; fruits.forEach(f=>{f.el.remove();f.supportA.remove();f.supportB.remove();}); fruits=[]; trailPts=[]; lastFrame=null; score=missed=0; updateScore(); while(fruits.length<MAX_FRUITS) spawnFruit(); if(!collecting) startTracking(); requestAnimationFrame(loop); }
function loop(ts){ if(!playing) return; if(lastFrame===null) lastFrame=ts; const dt=ts-lastFrame; lastFrame=ts; updateFruits(dt); requestAnimationFrame(loop); }

// Tracking control
function startTracking(){ webgazer.resume(); collecting=true; gazeDot.style.display=gazeDotEMA.style.display='block'; }
function stopTracking(){ webgazer.pause(); collecting=false; playing=false; gazeDot.style.display=gazeDotEMA.style.display='none'; }
startBtn.onclick = ()=>{ if(!calibrated) return alert('Calibrate first'); startTracking(); };
stopBtn.onclick = stopTracking;

// Mouse-trail toggle
function toggleMouseTrail(){ USE_MOUSE_TRAIL=!USE_MOUSE_TRAIL; toggleMouse.textContent = USE_MOUSE_TRAIL?'Mouse Trail ON':'Mouse Trail OFF';
  if(USE_MOUSE_TRAIL) area.addEventListener('mousemove', onMouseMove); else area.removeEventListener('mousemove', onMouseMove);
}
function onMouseMove(e){ const rect=area.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top; updateDebug(x,y); addTrailPoint(x,y); drawTrail(); checkSlices(); }
toggleMouse.onclick = toggleMouseTrail;
calBtn.onclick = startCalibration;

// WebGazer init & listener
webgazer.setGazeListener((data,ts)=>{
  if(USE_MOUSE_TRAIL||!data) return;
  const lx = data.x - areaRect.left, ly = data.y - areaRect.top;
  if(lx<0||ly<0||lx>area.offsetWidth||ly>area.offsetHeight) return;
  if(emaX===null){ emaX=lx; emaY=ly; } else { emaX=ALPHA*lx+(1-ALPHA)*emaX; emaY=ALPHA*ly+(1-ALPHA)*emaY; }
  gazeDot.style.left=lx+'px'; gazeDot.style.top=ly+'px';
  gazeDotEMA.style.left=emaX+'px'; gazeDotEMA.style.top=emaY+'px';
  updateDebug(emaX,emaY); addTrailPoint(emaX,emaY); drawTrail(); checkSlices();
});
webgazer
  .saveDataAcrossSessions(false)   // avoid mixing stale & fresh data during dev
  .begin()                         // starts video + model load
  .showVideo(false)
  .showFaceOverlay(false)
  .showFaceFeedbackBox(false);
// Enable Kalman filter for steadier predictions
webgazer.applyKalmanFilter(true);
// Optionally hide prediction point overlay that the library draws
webgazer.showPredictionPoints(false);

// Auto-start calibration
startCalibration();
</script>
</body>
</html>
